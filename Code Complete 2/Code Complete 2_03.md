# 3장. 준비는 철저하게: 선행조건

- 기초 공사가 잘 되지 않았거나, 계획을 잘못 수립했을 때 구현 과정에서 할 수 있는 최선의 행동은 손해를 최소화하는 것이다.
- 목수들 "두번 측정하고 한 번 잘라라"

## 3-1. 선행 조건의 중요성

- 품질이 좋은 소프트웨어를 개발하는 개발자들 → 프로젝트의 시작/중간/끝 단계에서의 품질을 중요시 함
- 프로젝트의 끝 단계에서 품질을 강조하는 경우
    - '테스트'는 전체 품질 보증 전략의 일부일 뿐 가장 영향력 있는 부분이 아님 → 테스트를 통해서는 엉뚱한 제품을 개발하거나 원하는 제품을 잘못된 방법으로 개발하는 것과 같은 문제점을 발견할 수 없음
    - 테스트하기 전, 구현을 시작하기 전부터 품질 보증에 대해 고민해야 함
- 프로젝트의 중간 단계에서 품질을 강조하는 경우
    - 구현 방법에 역점을 둠 → 본 책에서 중점적으로 다룰 예정
    - 이미 소프트웨어의 성패에 영향을 미치는 기초 작업이 어느 정도 진행된 상태
    - 구현하는 동안 적어도 현재 상황이 어떤지 판단하여, 작업을 되돌릴 여부를 결정할 수 있어야 함
- 프로젝트의 시작 단계에서 품질을 강조하는 경우
    - 요구사항 수집/설계에 집중함
- **준비 작업의 가장 중요한 목표는 위험 축소**이다. (가능한 초기에 주요 위험 요소를 제거)
- 불완전한 준비의 일반적인 원인은
    - **선행 작업에 투입되는 개발자가 전문가적인 지식을 가지고 있지 않다**.
    - 코드를 작성하는데 급급해 준비 작업을 하지 않는다.
    - 관리자들이 선행 조건 수행에 투자하는 시간을 못마땅해 한다. → 기술자로서 해야 하는 일 중에는 주위의 비기술자에게 개발 프로세스에 대해서 교육하는 것도 포함된다.
        - 개발자들은 소프트웨어 먹이 사슬의 최종 소비자. 아키텍트는 요구사항을 먹고, 설계자는 아키텍쳐를 먹고, 코더는 설계를 먹는다. → 요구사항이 오염되면, 결과적으로 구현도 오염된다.
        - 갈매기 → 신선한(오염된) 연어 → 신선한(오염된) 청어 → 신선한(오염된) 물 속 곤충
        - 결함이 발생한 시점에서 발견된 시점까지의 시간이 늘어감에 따라 결함을 수정하는데 드는 비용이 급격하게 증가한다.

## 3-2. 작업 중인 소프트웨어의 종류 결정

- 일반적인 세 가지 종류의 프로젝트
    - 비즈니스 시스템
    - 특수 임무용 시스템 **
    - 임베디드 안전 필수 시스템 **
- 비즈니스 시스템 프로젝트에서는 계획수림, 요구사항, 설계작업, 구현/테스트, 품질 보증 방법이 교차되는 반복적인 접근 방법을 사용하는 것이 좋음
    - 반복 기법을 사용하더라도 선행 조건을 중요시 해야함 → 선행 작업의 영향을 완전히 제거하지는 못함 (선행 조건을 무시한 반복적인 접근 방법은 선행 조건을 다룬 순차적인 접근 방법보다 훨씬 많은 비용이 들 수 있음)
    - 소프트웨어 특성상 반복적인 방법이 순차적인 방법보다 유용한 경우가 많음. 반복적인 방법은 선행 조건의 형식적인 정도나 완성도를 조절함으로써 적절하게 적용할 수 있음
    - 요구사항 중 80% 정도를 미리 명시하고 추가적으로 기술할 시간을 할당한 다음, 프로젝트를 진행하면서 가장 중요하다고 생각되는 새로운 요구사항만 수용하는 것을 추천
- 안전 필수 시스템은 신뢰성을 높이기 위해 요구사항이 변경되지 않아야 하기 때문에 순차적인 접근 방법이 좋음
- 구현시 가장 먼저 해야 할 일은 프로젝트에 가장 적합한 선행 조건이 무엇인가를 결정하는 것임

## 3-3. 요구사항 선행 조건

- 요구사항은 소프트웨어 시스템이 무엇을 수행해야 하는지에 대해 상세하게 기술하고 해결책을 구현하기 위한 첫 번째 과정이다.
- 명시적인 요구사항이 필요한 이유
    - 사용자가 시스템의 기능을 주도하게 되는데 도움이 된다. (요구사항이 명시적이지 않으면, 개발자가 프로그래밍하는 도중에 요구사항을 결정해버릴 수 있음)
    - 논쟁을 피하게 해준다.
    - 개발을 시작하고 난 후 변경사항을 최소화하는데 도움이 된다.
- 일반적으로 고객은 코드가 작성되기 전까지 자기에게 필요한 사항을 확실하게 설명하지 못한다. → 프로젝트가 진행될 수록 고객이 프로젝트를 더 잘 이해하게 되고, 자연스럽게 자신의 요구사항을 더 잘 이해하게 된다.
    - 일반 프로젝트는 개발 시에 25% 정도의 요구사항 변경을 경험하는데, 이는 일반적인 프로젝트에서 재작업하는 이유의 70~85%를 차지함
- 구현 중에 발생하는 요구사항의 변경을 잘 다루기 위한 방법
    - 코드 작업을 중단하고, 요구사항의 품질을 평가한다.
    - 모든 사람이 요구사항 변경 비용에 대해서 알게 한다. (기능에 심취한 사람들 → 일정/비용을 통해 정신이 번쩍 듦))
    - 요구사항 변경 절차를 구축한다. (변경 관리 위원회)
    - 변경 사항들을 수용하는 개발 접근 방법을 사용한다. (예. 진화적 프로토타이핑 접근 방법)
    - 진화적 프로토타이핑
        - 사용자 요구가 불투명할 때 사용
        - 구현된 프로토타입을 개선/보완하여 최종 시스템으로 완성시킴 (프로토타입 설계 → 구현 → 평가/요구사항 수정 → 설계 → ... )
        - 개발 단계 안에 유지 보수가 이루어지는 것으로 볼 수 있음
        - 장점
            - 소프트웨어의 개발이 제대로 되고 있는지 확인할 수 있음
            - 가시적인 결과인 프로토타입이 개발자/사용자 간의 의사소통 도구로 사용되어 구체적이고 원활하게 대화할 수 있음
            - 반복 과정을 통해 사용자의 요구가 충분히 반영된 요구 분석 명세서를 만들 수 있음
            - 사용자가 개발 과정에 적극 참여 가능
        - 단점
            - 프로토타입은 완전히 동작할 수 없는 것임에도 불구하고 사용자에게 빠른 시간안에 최종 결과가 나올 것처럼 착각을 줄 수 있음
            - 프포로타입은 과정을 관리/통제하기가 어려움 → 중간 과정을 점검할 수 있는 일정표/산출물이 없음
    - 프로젝트를 취소한다.
    - 프로젝트의 사업성을 주시한다. (좋은 생각처럼 보였던 요구사항도 기능으로서 점진적인 사업 가치를 평가해보면 터무니 없는 아이디어로 보일 수 있다.)
- 요구사항 체크 리스트 (얼마나 확실한 요구사항을 가지고 있는지 확인하는 척도)

## 3-4. 아키텍쳐 선행 조건

- 소프트웨어 아키텍쳐는 설계 중에서 상세한 부분을 담은 틀이다. (최상위 설계)
    - 아키텍쳐: 시스템 전반에 적용되는 설계상의 제약 사항
    - 상위 수준 설계: 서브 시스템이나 여러 클래스 수준에 적용 가능하지만 시스템 전반에 적용된다는 보장은 없는 설계상의 제약사항
- 아키텍쳐의 품질이 시스템의 개념적인 무결성을 결정함 (나쁜 아키텍쳐는 구현을 불가능하게 만들거나, 잘못된 방법(예를 들어, 촛불을 끄려고 소방차를 부른다)으로 문제를 해결하게 함)

> 무결성:  데이터의 정보가 변경되거나 오염되지 않도록 하는 원칙, 항상 정상적인 데이터를 유지하는 것

- 전형적인 아키텍쳐의 구성 요소
    - 프로그램 구조
        - 시스템을 일반적인 말로 기술한 개요
        - 작성하고 있는 클래스가 시스템에 어떻게 기여하게 될 것인지 이해할 수 있어야 함
        - 최종 구조에 대한 대안을 고려했던 근거와 다른 대안들 대신 지금의 구조를 선택한 이유 → 설계에 대한 논리적인 근거는 설계 자체만큼이나 유지보수가 중요함
        - 프로그램 내의 중요 빌딩 블록을 정의해야 함
            - 빌딩 블록은 요구사항에서 명시한 기능이 적어도 1개는 들어가야 함
            - 각 빌딩 블록이 책임져야 하는 내용이 명확하게 정의되어야 함 (한 분야를 책임지며, 다른 빌딩 블록에 대해서는 가능한 조금 알아야 함)
            - 각 블록간 커뮤니테이션 규칙도 명확해야 함 (직접 사용할 수 있는 블록, 간접 사용할 수 있는 블록, 절대로 사용해서는 안되는 블록)
    - 주요 클래스
        - 시스템의 80%를 담당하는 20%의 클래스 명시
        - 클래스가 맡은 역할과 클래스 사이의 상호작용 규명
        - 클래스 계층 구조, 상태 전이, 객체 지속성에 대한 설명 포함
		
> 객체 지속성 (object persistence) : 소프트웨어에서 객체는 어느 정도의 공간을 점유하고 특정 시간 동안 존재하게 된다. 수식 내에서 임시적으로 발생하는 객체에서부터 데이터베이스에 있는 객체까지 객체에 대한 지속성이 다르다. 지속성은 객체의 존재가 시간(객체를 생성한 무엇인가가 조재를 끝마쳐도 객체는 계속 존재함)이나 공간(객체가 생성되었던 주소 공간에서 이동될 수 있음)을 초월해서 여기저기 옮겨다니는 성질을 의미함 (일반적인 프로그램 영역: 수식 평가의 임시적인 결과, 절차적인 프로그램의 지역변수, 프로그램 언어 자체적인 변수, 전역 변수, heap 항목 / 데이터베이스 기술 영역: 프로그램 실행 간 존재하는 데이터, 프로그램의 다양한 버전 간 존재하는 데이터, 프로그램보다 오래 남는 데이터)

- 데이터 설계 (중요한 파일과 테이블 설계를 기술)
- 비즈니스 규칙 (예. 고객의 정보가 30초 이상 남아 있으면 안됨 등)
- 사용자 인터페이스 설계 (비즈니스 규칙이나 프로그램의 결과에 영향을 미치지 않고 새로운 사용자 인터페이스로 대체할 수 있도록 모듈화해야 함)
- 자원 관리 (데이터베이스 연결, 스레드, 핸들, 메모리 같이 자원을 관리하기 위한 계획 기술)
- 보안
- 성능
    - 성능을 염려한다면 요구사항에 원하는 성능을 명시해야 함
    - 성능 목표 달성을 위해 특정 알고리즘이나 데이터 형식을 사용해야 한다면 이를 언급
- 확장성 (시스템이 확장될 가능성이 없거나 확장성이 문제가 되지 않더라고 그러한 가정에 대해 명시적으로 언급해야 함)
- 상호운용성
- 국제화와 지역화
- 입력/출력
- 오류 처리 (오류 처리를 위해 굉장히 많은 (어떤이는 90%라고 추정) 코드가 작성되므로 오류를 처리하기 위한 일관된 방법을 명시해야 함
    - 오류 처리와 관련해 고려해야 할 사항
    - 오류 수정을 하는가(오류로부터 복구하기 위한 시도)? 검출만 하는가(프로그램 계속 진행 또는 중단)?
    - 오류 검출이 능동적? 수동적?
    - 오류 전달 과정 (오류 검출하면 해당 데이터를 바로 처리하거나 프로그램의 모든 동작이 완료될때까지 기다렸다가 처리)
    - 오류 처리 메시지에 관한 규약
    - 예외의 처리 방법 (코드 내에서 언제 예외를 던지고, 어디서 처리하는지)
    - 데이터 검증을 위해 각 클래스가 어느 수준까지 책임져야 하는가? (각 클래스가 자신의 데이터 검증 또는 시스템의 데이터를 검증하는 특정 클래스가 있음)
- 장애허용 (오류를 검출하고, 가능한 경우에는 오류로부터 복구 또는 시스템에 미치는 악영향을 방지하는 시스템의 신뢰도를 높이는 기술)
    - 예를 들어,
    - 오류를 발견했을 때 시스템이 자료를 백업하거나 다시 시도함
    - 서로 다른 방법을 이용하는 클래스들을 가지고 평균값, 중간값, 최빈값 등에서 선택
    - 시스템의 나머지 부분에 악영향을 끼치지 않는 가짜값으로 대체
- 구조적인 실행 가능성
    - 시스템이 기술적으로 실행 가능함을 보여줌
- 과도한 엔지니어링
    - 견고함: 시스템이 오류를 발견한 후에도 계속해서 실행할 수 있는 능력
    - 아키텍쳐는 요구사항에 명시된 것보다 더 견고한 시스템을 명시 → 최소한의 견고함을 가진 여러 부분으로 구성된 시스템은 전체적으로 봤을 때 요구된 것보다 견고함이 떨어질 수 있음
    - 아름다움은 간결함에 있다. 과도한 추상화/패턴을 위한 패턴/인터페이스를 위한 인터페이스를 피한다.
- 구입과 구현 결정
    - 모든 것을 구입하는 대신 사거나 무료로 제공되는 오픈소스 소프트웨어를 이용
    - 시장에서 판매 하는 것을 이용하지 않고 구현해야 한다면, 구현을 통해 어떤 부분에서 능가할 것인지 설명해야 한다.
- 재사용 결정
- 변경 전략
    - 기능 향상을 고려했으며, 해당 기능 향상을 쉽게 구현할 수 있음을 보여주어야 한다.
- 일반적인 아키텍쳐 품질
    - 아키텍쳐의 목표가 명확하게 기술되어야 함 (예. 두 시스템이 동일한 기능을 제공하더라도 변경 가능성이 주요 목표인 시스템에 대한 설계와 아직 성능 목표가 정해지지 않은 시스템에 대한 설계는 다를 것임)
    - 모든 주요 결정사항에 대한 동기를 기술해야 함 (항상 그래왔다 → XXX)
    - 훌륭한 소프트웨어 아키텍쳐는 대부분 기계/언어에 독립적임 (단, 프로그램의 목적이 특정한 기계나 언어를 활용할 때는 적용되지 않음)
    - 여러 관점이 들어가야 한다. (예. 집의 설계도 = 높이, 바닥, 골조, 전선 설계도 등 집에 대한 여러 가지 관점을 포함함)
    - 아키텍쳐에 대한 확신이 있어야 한다.
	
## 3-6. 선행 조건에 소요되는 시간

일반적으로 제대로 진행되는 프로젝트는 요구사항, 아키텍쳐, 사전 계획수립을 위해 전체 노력의 10/20%정도, 전체 시간의 20/30%정도를 투자한다. (상세설계는 구현의 일부이므로 여기에 포함되지 않음)
# 5장. 구현설계

## 5.1 설계의 어려움

- 소프트웨어 설계란, 컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 계획에 대한 구상이나 창작, 도구를 뜻함 → **요구사항을 코드작성/디버깅에 연결하는 작업**
- 설계는 불명확한 문제다
    - 불명확한 문제: 전체 혹은 일부를 해결해야만 정의할 수 있는 문제
    - **문제를 명확하게 정의하려면 문제를 한 번 '해결'해야 함**
    - 예) 타코마다리 붕괴 - 다리가 붕괴될 때 가지 엔지니어는 공기 역학을 적용해야 했었는지 알지 못함. 다리를 짓고서야 다리를 다시 짓게 만든 문제를 추가로 고려해야하 한다는 사실을 배움
- 설계는 엉성한 프로세스다
    - 설계 과정은 최종 결과물만큼 깔끔하지 않다.
    - **실수를 하는 것이 설계의 핵심** → 설계 단계에서 실수/수정하는 것이 코드 작성 후에 수정하는 것보다 적은 비용 소모
    - 충분한 상태를 알기 어려움 → **설계를 언제 끝낼 것인가? 더 이상 시간이 없을 때 까지**
- 설계는 절충과 우선순위의 문제다
    - 서로 상충하는 설계 특징을 비교하여 그 특성들 사이의 균형을 맞추는 것이 설계자의 주요 업무임
- 설계에는 제약이 따른다
    - 설계의 핵심은 어느정도는 가능성을 만들고, 어느정도는 가능성을 제한한다는데 있음
    - 자원이 제한적이기 때문에
- 설계는 비결정적이다
    - 어떤 목적을 달성할 수 있는 방법은 한 가지 이상임
- 설계는 발견적 학습 과정이다
    - 설계 기법은 예상된 결과를 만들어내는 반복적인 처리 과정이라기 보다 발견적 학습(경험 법칙, 작동하는지 시도해보는 것)이라고 할 수 있음
    - 어떤 작업에서 효과가 있던 설계 툴이나 기법이 다음 프로젝트에서는 효과가 없을 수 있음
- 설계는 창발적이다
    - 설계는 설계 검토, 격식없는 토론, 코드 작성, 코드 수정 경험을 통해 진화/발전함
    - 초기 개발 과정에서 어느 정도의 설계 변경을 거치게 되고, 그 후에 애초 예상했던 것보다 훨씬 많은 내용이 변경됨

창발성: 전체는 부분의 합 이상. 창발된 성질이나 실체와 같은 대상들이 더 근본적인 대상들로부터 발생하지만, 근본적인 대상으로 환원되지 않으며 그 자체로 특수한 지위를 차지하는 것을 의미한다

## 5.2 핵심 설계 개념

### 복잡성 관리 - 소프트웨어의 주요 기술적 의무

- 본질적 어려움과 비본질적 어려움
    - 소프트웨어 개발은 본질적/비본질적 어려움이 섞여 있음
    - 본질적 속성: 어떠한 사물이 그러한 사물이 되기 위해서 반드시 가져야 하는 속성 (예. 자동차가 되기 위해서 엔진, 바퀴, 문이 있어야 함)
    - 비본질적 속성: 특정 사물을 일컬을 때 그것이 무엇이라고 결정하는데 영향을 주지 않는 우연의 산물 (예. 자동차 문이 2개일 수도 있고, 4개일 수도 있음)
    - 본질적 어려움: 복잡하고 무질서한 현실 세계와 상호작용하고, 종속 관계와 예외 상황들을 정확하게 규명하며, 대충이 아닌 정확히 맞는 솔루션을 설계해야 함 (본질적인 어려움의 근원은 소프트웨어 개발의 본질적이고 비본질적인 복잡성 때문임)
    - 비본질적 어려움: 중요한 비본질적 어려움은 오래전에 해결되었음 (어셈블리어 → 3세대 언어로 진화, 통합프로그래밍개발환경 등)
- 복잡성 관리의 중요성
    - 프로젝트가 기술적인 이유로 실패한 경우에는 그 원인을 복잡성 관리 부족에서 찾을 수 있음 → **소프트웨어의 주요 기술적 의무는 복잡성을 관리하는 것**
    - **한 번에 한 부분을 제대로 집중할 수 있게 프로그램을 구성**해야 함 (한 번에 생각해야 하는 프로그램의 크기를 최소화 함)
    - **복잡한 문제를 간단한 문제로** 나눔
    - 객체를 정의할 때 한 번에 **하나의 기능에만 집중**할 수 있도록 작업을 나눔
- 복잡성을 해결하는 방법
    - 두뇌가 한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화 함
    - 비본질적인 복잡성이 불필요하게 증가하지 않도록 함

### 바람직한 설계의 특징

- 복잡성 최소화 (재치있는 설계는 피하고, 간단하고 이해하기 쉬운 설계를 만듦, 특정한 부분을 살펴보고 있을 때 다른 부분에 대해서도 함께 살펴봐야 한다면 잘못된 설계라고 할 수 있음)
- 유지보수의 편리함 (유지보수 개발자가 작성한 코드에 대해서 물어볼만한 질문을 떠올려 봄)
- 느슨한 결합 (프로그램의 각 부분 사이의 연결을 최소화, 추상화/캡슐화/정보은닉과 같은 방법 사용)
    - 추상화: 사물이 가지는 특성을 잘 정리하여 필드와 메서드로 표현하는 과정 (공통의 속성/기능을 묶어 이름 붙이기, 패턴 찾아내기) → 예) 사자/물고기/토끼 를 '동물'로 추상화할 것인가? '생물'로 추상화할 것인가?
    - 캡슐화: 구현되는 부분을 외부에 드러나지 않도록 감싸 이용 방법만을 알려 주는 것, 데이터 구조(데이터 자체)와 데이터를 다루는 방법(메서드)을 결합시켜 묶는 것
    - 정보 은닉: 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 은닉 (객체, 상속, 캡슐화 등은 정보 은닉의 수단에 불과, 좋은 정보 은닉은 잘 된 추상화를 통해 얻어짐)
        - 객체의 구체적인 타입 은닉 (= 상위 타입 캐스팅)
        - 객체의 필드 및 메소드 은닉 (= 캡슐화)
        - 구현 은닉 (= 인터페이스 및 추상 클래스 기반의 구현)
- 확장성 (내부 구조를 해치지 않고 시스템의 기능을 개선할 수 있음)
- 재사용성 (현재 시스템의 일부를 다른 시스템에서 사용할 수 있도록 설계함)
- 높은 팬인(fan-in) (특정 클래스를 사용하는 클래스의 수가 많음 → 유틸리티 클래스를 잘 활용하도록 설계함)
- 낮은 팬아웃(fan-out) (특정 클래스가 다른 클래스를 적게 사용함)
- 이식성 (시스템을 다른 환경으로 쉽게 이동시킬 수 있음)
- 간결성 (불필요한 부분이 없게 시스템을 설계, 더이상 추가할 내용이 없을 때가 아니라 더 이상 뺄 내용이 없을 때)
- 계층화 (특정 계층을 재구성할 때, 인터페이스 계층을 제외한 어떠한 코드도 변경할 필요가 없음)
- 표준기법들 (표준화되고 일반적인 접근 방법을 사용)

### 설계 수준

하나의 시스템에도 여러 상세 수준이 있는데, 각 상세 수준마다 설계가 필요함 (1) 시스템은 2) 서브시스템으로 구성됨. 서브시스템은 3)클래스로 분할되고, 클래스는 다시 4) 루틴과 데이터로 나뉨. 5) 각 루틴의 내부도 설계함)

- 소프트웨어 시스템
- 서브시스템/패키지
    - 중요한 서브시스템 식별 (데이터베이스, 사용자 인터페이스, 비즈니스 규칙, 명령 해석기, 보고서 엔진 등)
        - 비즈니스 규칙: 컴퓨터 시스템에 입력하는 법률/규칙/정책/절차
        - 사용자 인터페이스
            - **사용자 인터페이스 컴포넌트를 고립**시켜야 함 (프로그램의 나머지 부분에 지장을 주지 않고 발전할 수 있도록)
            - GUI/명령줄 인터페이스, 메뉴 처리, 윈도우 관리, 도우말 시스템 등에 대한 여러 개의 종속적인 서브시스템/클래스를 사용
        - 데이터베이스 접근: **데이터베이스 접근에 대한 구현 세부사항을 감추어 프로그램 대부분이 저수준 구조체를 다루기 위한 복잡한 세부 사항에 대해 걱정할 필요가 없게 만들고**, 비즈니스 수준에서 사용되는 형태로 데이터를 처리할 수 있도록 해야 함
        - 시스템 의존성: 운영체제에 대한 의존성을 서브시스템으로 패키지화 함
    - 각 서브시스템이 다른 서브시스템을 어떻게 사용할 것인지 결정 → 모든 서브시스템이 서로 소통할 수 있다면 이들을 나눔으로써 얻는 장점이 사라짐. 커뮤니케이션을 제한하여 각 서브시스템을 의미있게 만듦
    - 서브시스템 간 상호작용이 순환관계를 가지지 않도록 해야 함 (클래스 A → B사용, B → C 사용, C→ A 사용)
    - (몇 주 이상 소요되는 모든 프로젝트에 필요)
- 클래스
    - 시스템에 필요한 모든 클래스를 구체화함
    - 각 클래스가 시스템의 나머지 부분과 상호작용하는 방법에 대한 세부적인 사항도 명시 → 클래스의 인터페이스 정의
    - 개별적인 클래스로 구현할 수 있을만큼 자세한 수준으로 모든 서브시스템을 확실하게 분해해야 함

객체(인스턴스): 실행중인 프로그램에 존재하는 구체적인 entity(개체). 프로그램을 실행할 때 생성되는 특정한 값과 속성을 갖는 동적인 것
클래스: 프로그램 코드로 정적인 것

- 데이터/루틴
    - 클래스의 루틴을 완전하게 정의하는 작업을 통해 클래스의 인터페이스에 대해 더 잘 이해하게 되면, 인터페이스도 그것에 맞게 변경해야 하는 경우가 생김
    - 공식적으로 할 필요가 없다면 머리속으로라도 해야 함
- 내부 루틴
    - 각 루틴의 상세한 기능을 구현
    - 내부 루틴 설계는 일반적으로 개별적인 루틴을 개발하는 개발자의 몫임
    - 의사 코드 작성 → 알고리즘 살펴보기(참고서적 참고) → 코드 단락 구성 → 프로그래밍 언어로 코드를 작성

## 5.3 설계 빌딩 블록: 발견적 학습

설계에는 정답이 없다 → 발견적 학습(1장 참고)을 효과적으로 적용해야 함

** 복잡성 관리 측면에서 각 발견적 학습을 정리

### 현실 세계의 객체를 찾아라

- 객체와 객체의 속성(메서드/데이터)을 식별한다.
- 각 객체에 무엇을 할 수 있는지 결정한다.
- 각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다.
    - 포함
    - 상속
- 각 객체에서 다른 객체에게 보일 부분을 결정한다. (공개/비공개 부분)
- 각 객체의 공개 인터페이스를 정의한다.

### 일관성있게 추상화 하라

- 추상화를 통해 공통 특성들에 집중하고 다른 세부 사항은 무시한다. (추상화는 현실의 복잡성을 다루는 주요한 방법이며, 이미 대부분의 현실 객체는 어느정도 추상화 되어 있음. 예) 집 = 창문, 문, 배선, 배관, 단열재, ...)
- 훌륭한 개발자는 루틴 인터페이스 수준(손잡이 수준), 클래스 인터페이스 수준(문 수준), 패키지 인터페이스 수준(집 수준)의 **단계적인 추상화**를 제공할 수 있다.

### 구현 세부 사항을 캡슐화 하라

- 추상화: 객체를 높은 수준에서 볼 수 있도록 함
- 캡슐화: 다른 수준에서 해당 객체를 특정 수준 이상으로 볼수 없게 함 (복잡한 부분을 보지 못하게 함)

### 상속이 설계를 단순화 할 수 있을 때 상속하라

- 상속은 객체 사이의 유사성과 차이점을 정의하는 것이다.
- 다형성: 자식 클래스에 동일한 연산을 지원하는 언어의 능력

### 비밀을 숨겨라 (정보 은닉)

- **정보 은닉은 복잡성을 감추는데 중점**을 두고 있기 때문에 소프트웨어의 주요 기술적 의무(복잡성 관리)에 강력한 기법임
- 정보 은닉 = 비밀: 소프트웨어 개발자가 설계나 구현에서 나머지 프로그램으로부터 한 부분을 숨기기로 결정하는 것임
- 클래스 설계에서 가장 중요한 작업 중 하나는 어떤 기능을 클래스 외부로 알리고 어떤 기능을 비밀로 남길지 결정하는 것임(클래스의 가시성). 클래스에 대한 인터페이스는 가능한 한 내부 작업을 드러내지 않아야 함

```csharp
int id = ++_g_maxId;
```

```csharp
IdType id = NewId();
```

- 정보 은닉의 종류
    - 특별하게 관심이 없는 경우에 고민할 필요가 없도록 복잡성을 감추는 것
    - 변경이 발생했을 때 그 효과가 일부에만 영향을 미치도록 변경의 원인을 감추는 것
- 정보 은닉의 장애물
    - 정보의 지나친 배분 (예. 시스템 전체에 상수 100을 하드코딩 한 경우, 시스템 전체에 사용자와 상호작용하는 기능을 끼워넣음)
    - 순환 의존성 (예. 클래스 A에 있는 루틴이 B의 루틴을 호출하고, B의 루틴이 A의 루틴을 호출)
    - 전역 데이터로 오해받는 클래스 데이터
        - 다른 루틴이 전역 데이터를 다루고 있다는 사실을 모름
        - 다른 루틴이 전역 데이터를 다루고 있다는 것을 알지만 정확하게 무엇을 하는지 알지 못함
    - 성능 손해 (정보 은닉과 성능에 대해 충분히 고려하면 두 가지 목표를 모두 달성할 수 있음)
        - 객체 생성과 루틴 호출이 추가되는 것처럼 느껴질 수 있지만,
        - 코드 수준에서의 성능 개선을 미리 준비하는 가장 좋은 방법은 코드를 가능한한 모듈화 하는 것임
- **"이 클래스에서 무엇을 숨겨야 하는가?"** 라고 묻는 것이 인터페이스 설계 문제를 해결하는데 가장 중요 (무엇을 숨겨야하지? 라고 질문하는 습관을 통해 설계에 관한 결정하기 어려운 문제의 상당수가 해결될 수 있음)

### 변경될 것 같은 영역을 찾아라

- 변경의 효과가 한 루틴이나 클래스, 패키지에 제한되도록 불안정한 영역을 고립시킴
    - 변경될 것처럼 보이는 항목을 찾음 → 요구사항 개발시 변경 가능성이 있는 것의 목록과 각 변경이 일어날 확률을 정리
    - 변경될 것 같은 항목을 분류 → 1단계에서 찾은 변경되기 쉬운 요소를 고유한 클래스로 분류
    - 변경될 것처럼 보이는 항목을 고립 → 변화가 특정 클래스의 내부에 제한되어 외부는 영향을 받지 않도록 인터페이스를 설계 (인터페이스가 비밀을 보호해야 함)
- 변경될 가능성이 큰 영역
    - 비즈니스 규칙
    - 하드웨어 의존성 (장치 사이의 의사소통에 대한 인터페이스)
    - 입력과 출력 → 파일 포맷
    - 표준을 따르지 않는 언어 기능 → 확장 기능은 환경(다른 하드웨어, 다른 언어, 새로운 버전)에 따라 지원되지 않을 수 있음

    표준을 따르는 기능?

    - 어려운 설계 및 구현 부분 → 어려운 설계와 구현 부분은 잘못 구현될 가능성이 있음
    - 상태 변수 → 프로그램의 상태를 나타내고 다른 데이터보다 자주 변경되는 경향이 있음
        - 상태 변수로 불린 변수 대신 열거형을 사용할 것(새로운 상태를 추가하는 일이 흔히 발생)
        - 상태 변수에 직접 접근하지 말고 접근 루틴을 사용
    - 데이터 크기 제약

### 결합을 느슨하게 유지하라

- 결합: 클래스나 루틴이 다른 클래스나 루틴과 얼마나 밀접하게 연관되어 있는지를 기술
- 다른 클래스나 루틴과 **작고 직접적이며 눈에 띄고 유연한 관계(단순한 관계)**를 갖는 클래스와 루틴을 생성하는 것이 목표임 (느슨한 결합)

```csharp
InitVars(var1, var2, ..., varN); // 호출 모듈이 전달해야 하는 모든 매개 변수와 함께
// 실제로 함수 내부에서 무슨일이 벌어지는지 알아야 함 -> 강력한 결합
```

- 모듈 사이의 결합을 평가하는 기준
    - 크기: 모듈 사이의 연결 횟수
        - 매개변수가 1개인 루틴 vs 매개변수가 6개인 루틴
        - 4개의 공개 메서드를 갖는 클래스 vs 37개의 공개 메서드를 노출한 클래스
    - 가시성: 두 모듈간의 연결이 얼마나 명시적인지를 나타냄
        - 매개변수 목록에 데이터를 전달 vs 전역 데이터를 수정
    - 유연성: 얼마나 쉽게 모듈 사이의 연결을 변경할 수 있는가

```csharp
public class Employee {
	DateTime EmploymentDate { get; set; } // 입사 날짜
	int Position { get; set; } // 직급
	...
}

int LookupVacationBenefit(Employee employee); // 휴가 일수 조회

// Employee 객체를 가지지 않는 루틴에서는
// EmploymentDate와 Position 데이터만으로 Employee 객체를 생성한 후
// LookupVacationBenefit 메서드를 호출해야 함
```

```csharp
int LookupVacationBenefit(DateTime employmentDate, int position)
```

- 결합의 종류
    - 간단한 데이터 매개 변수 결합: 두 모듈 사이에서 전달되는 모든 데이터가 기본 데이터형이고 모든 데이터가 매개변수로 전달됨
    - 간단한 객체 결합: 모듈이 객체를 인스턴스화함
    - 객체 매개변수 결합: Object1이 Object2에게 Object3을 넘겨달라고 요구함 → Object2가 Object3에 대해 알아야 함 (좀 더 강한 결합)
    - 의미론적인 결합: 한 모듈이 다른 모듈의 내부 작동에 대한 논리적인 지식을 사용 → 사용된 모듈의 코드를 변경하면 모듈을 사용하는 코드가 컴파일러로 감지할 수 없게 망가질 수 있음
        - 예 1) 모듈1이 모듈2에게 제어 플래그를 전달 → 모듈2가 전달 받은 제어 플래그로 무엇을 할지 모듈1이 알아야 함. 단, 열거형/객체로 제어 플래그를 정의하면 문제 없음
        - 예 2) 모듈1이 전역 데이터를 수정한 후, 모듈2가 그 전역 데이터를 사용
        - 예 3) 모듈1이 BaseObject를 모듈2전달. 모듈2는 모듈1이 실제로는 DerivedObject를 전달한다는 것을 알고 있기 때문에 BaseObject를 DerivedObject로 변환하여 DerivedObject의 메서드를 호출

        위의 예 3은 다형성이 아닌가? → 다형성이 아님;;;

- 클래스와 루틴은 복잡성을 줄이기 위해서 가장 먼저 사용하는 도구임. 클래스와 루틴이 일을 더 단순하게 만들고 있지 않다면, 제 역할을 못하고 있는 것임

### 일반적으로 널리 사용되는 디자인 패턴을 찾아라

- **디자인패턴은 소프트웨어에서 가장 흔히 발생하는 많은 문제를 해결하는 데 사용할 수 있는 이미 만들어진 솔루션의 핵심적인 부분**을 제공함 (패턴은 숙련된 개발자 대부분이 알고있는 내용에 능률적이고 효과적인 대화가 가능하도록 이름을 붙인 것일 뿐임)
- 일반적으로 널리 사용되는 패턴: Adapter, Bridge, Decorator, Facade, Factory Method, Observer, Singleton, Strategy, Template Method, ...
    - 패턴은 이미 만들어진 추상화를 제공함으로서 복잡성을 줄여줌 (다른 개발자들에게 코드에 있는 설계 접근 방법을 이해시키려고 모든 코드에 관해서 설명할 필요가 없음)
    - 패턴은 일반적으로 널리 사용되는 해결책의 세부 사항들을 규정함으로써 오류를 줄임 (소프트웨어 설계 문제는 문제가 한 두번 해결되고 난 후 완전하게 보이는 특징이 있음 → 수년간 축적된 지혜를 한번에 얻을 수 있음)
    - 패턴은 대안을 제안함으로써 발견적 학습의 가치를 제공함 (패턴 목록을 보고 '내 설계 문제에 적합한 패턴이 어느것이지?' 라고 물을 수 있어야 함)
    - 패턴은 설계에 대해 수준 높은 논의를 할 수 있게 해서 의사소통을 원활하게 함 (몇마디 속에 많은 이야기를 담을 수 있음)
- 패턴을 사용할 때 코드를 억지로 패턴에 끼워 맞추지 않아야 함
- 패턴이 적절한 설계 솔루션이기 때문이 아니라 패턴을 사용해보기 위해 패턴을 사용하지 않아야 함

### 다른 발견적 학습

- 응집력을 강하게 하라
    - 클래스에 있는 모든 루틴이나 루틴 내 모든 코드가 얼마나 밀접하게 중심 목적을 지원하고 있는가를 나타냄
    - 연관성이 높은 기능을 포함하는 클래스를 응집력이 강하다고 표현함
- 계층을 만들어라 → 계층을 이용하면 현재 다루고 있는 수준에만 집중할 수 있음
- 클래스 계약을 형식화 하라
    - 각 클래스의 인터페이스를 나머지 프로그램과의 계약으로 생각함
    - 선행조건: 클래스의 클라이언트가 클래스와 맺는 조건 (데이터 x,y,z를 제공하기로 약속하고, 그 데이터들이 a,b,c라는 특성을 갖는다면,)
    - 후행조건: 객체가 클라이언트와 맺는 계약 (8,9,10이라는 제약내에서 1,2,3연산을 수행할 것을 약속한다)
- 책임을 할당하라 → 객체가 무엇을 책임져야 하는지 물음
- 테스트가 가능하도록 설계하라 → 테스트가 가능하도록 설계하면 더 규격화된 클래스 인터페이스가 만들어지는 경향이 있음
- 실패를 피하라 → 다른 성공적인 설계의 특성을 단순히 따르지 않고, 실패할 수 있는 경우를 주의 깊게 고려해야 함
- 결합 시점을 의식적으로 선택하라 → 특정 값이 변수에 결합하는 시점을 선택하라 ???
    - Lazy Evaluation과 연결해서 생각해보기
- 제어 지점을 정하라
- 주먹구구식 기법의 사용을 고려하라 → 효과가 있는 주먹구구식 해결책이 효과없는 우아한 해결책보다 나음
- 다이어그램을 그려라
- 모듈화를 유지하라 → 클래스/루틴을 '블랙박스 (입출력값은 알지만 안에서 무슨일이 일어나는지는 알지 못함)'처럼 만듦
- **발견적 접근 방법을 위한 지침**
    - 한 가지 접근 방법에 매달리지 않아야 함
    - 최선을 다했는데도 방법을 찾을 수 없을 때에는 문제에서 손을 놓는 것이 끝까지 잡고 늘어지는 것보다 더 빨리 해결하는 경우도 있음
    - 설계 문제 전체를 한 번에 해결할 필요가 없음 (더 많은 정보/경험/지식을 갖게 될 때까지 문제를 해결하지 않은 채로 남겨두는 것이 나을 수 있음)

## 5.4 설계 실천법

### 반복

- 설계 과정을 몇 번 반복할 수 있는 여유가 필요 (설계를 되풀이할때마다 전체 설계를 향상시킬 수 있음)
- 여러 가지 방법으로 시도해보는 과정 속에서 문제를 상위수준과 하위수준 관점에서 모두 바라볼 수 있게 됨
- 한 가지 방법으로 문제를 해결하면 문제를 더 잘 해결할 수 있는 다른 접근 방법에 대한 통찰력을 제공하는 경우가 많음

### 분할과 정복

- 프로그램을 서로 다른 영역으로 나누고 각 부분을 개별적으로 처리
- 점증적인 개선

### 하향식과 상향식 설계 접근 방법

- 하향식 설계: 높은 추상화 수준에서 시작 (분해)
- 상향식 설계: 구체적인 것에서 시작해 일반적인 쪽으로 작업 (결합)
    - 유사한 시스템이 이미 개발되어 있을 때 상향식 접근 방법을 사용하면 이전 시스템을 살펴보고 무엇을 재사용할 수 있는지 살펴본 후 새로운 시스템의 설계를 시작할 수 있음

### 실험적인 프로토타이핑

- 구현 세부사항을 이해하기 전에는 설계가 적합한지 실제로 알 수 없는 경우가 있음 → 최소한 부분적으로라도 문제를 해결하기 전까지는 문제를 완전하게 정의할 수 없음
- 실험적 프로토타이핑: 특정한 설계 질문에 답하는데 필요한 최소한의 임시 코드(쓰고 버릴 코드)를 작성하는 것
    - 프로토타이핑은 개발자가 질문에 답하는데 필요한 최소한의 코드를 작성해야함
    - 프로토타이핑은 설계 질문이 구체적일 때 효과가 있음
    - 개발자가 프로토타이핑에 사용한 코드를 쓰고 버리는 코드로 취급해야 효과가 있음 (그렇지 않으면 개발자는 시스템을 구현하게 됨. 이러한 문제를 방지하고자 제품 코드와 다른 언어로 프로토타이핑 코드를 작성함)

### 협력적인 설계

- 설계에서는 공식/비공식적이든 개발자 두 명이 한명보다 나음
- 자신의 작업을 검토해 줄 수 있는 동료가 없다면, 초기 설계 작업을 일주일 후에 살펴봄 → 이전에 작업했던 내용을 잊어버려 스스로 잘 검토할 수 있게 됨

### 설계를 얼마나 해야 할까?

- 코드 작성을 시작하기 전에 설계를 얼마나 해야 할까? 설계를 문서화하기 위해 얼마나 형식화 해야 하는가?
- 설계의 가장 큰 어려움은 너무 쉬워서 설계할 필요가 없다고 생각하는 순간에 발생하는 경향이 있음 (단, 설계 관련 문서 작업이 지나쳐서 어려움을 겪는 상황도 있음)

### 설계 작업 기록하기

- 설계 문서를 코드 자체에 넣기→ 가장 핵심적인 설계 결정 사항은 코드 주석으로 문서화
- 설계에 대한 논의와 결정을 위키에 기록하기
- 이메일로 요약하기
- 디지털 카메라 사용하기
- 설계 플립 차트를 보관하기
- CRC (클래스/책임/협력자) 카드를 사용하기
- 적절한 상세수준에서 UML 다이어그램을 작성하기

## 5.5 잘 알려진 방법론에 대한 의견
# 5장. 구현설계

## 5.1 설계의 어려움

- 소프트웨어 설계란, 컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 계획에 대한 구상이나 창작, 도구를 뜻함 → 요구사항을 코드작성/디버깅에 연결하는 작업
- 설계는 불명확한 문제다
    - 불명확한 문제: 전체 혹은 일부를 해결해야만 정의할 수 있는 문제
    - 문제를 명확하게 정의하려면 문제를 한 번 '해결'해야 함
    - 예) 타코마다리 붕괴 - 다리가 붕괴될 때 가지 엔지니어는 공기 역학을 적용해야 했었는지 알지 못함. 다리를 짓고서야 다리를 다시 짓게 만든 문제를 추가로 고려해야하 한다는 사실을 배움
- 설계는 엉성한 프로세스다
    - 실수를 하는 것이 설계의 핵심 → 설계 단계에서 실수/수정하는 것이 코드 작성 후에 수정하는 것보다 적은 비용 소모
    - 충분한 상태를 알기 어려움 → 설계를 언제 끝낼 것인가? 더 이상 시간이 없을 때 까지
- 설계는 절충과 우선순위의 문제다
    - 서로 상충하는 설계 특징을 비교하여 그 특성들 사이의 균형을 맞추는 것이 설계자의 주요 업무임
- 설계에는 제약이 따른다
    - 설계의 핵심은 어느정도는 가능성을 만들고, 어느정도는 가능성을 제한한다는데 있음
    - 자원이 제한적이기 때문에
- 설계는 비결정적이다
    - 어떤 목적을 달성할 수 있는 방법은 한 가지 이상임
- 설계는 발견적 학습 과정이다
    - 설계 기법은 예상된 결과를 만들어내는 반복적인 처리 과정이라기 보다 발견적 학습(경험 법칙, 작동하는지 시도해보는 것)이라고 할 수 있음
    - 어떤 작업에서 효과가 있던 설계 툴이나 기법이 다음 프로젝트에서는 효과가 없을 수 있음
- 설계는 창발적이다
    - 설계는 설계 검토, 격식없는 토론, 코드 작성, 코드 수정 경험을 통해 진화/발전함

창발성: 전체는 부분의 합 이상. 창발된 성질이나 실체와 같은 대상들이 더 근본적인 대상들로부터 발생하지만, 근본적인 대상으로 환원되지 않으며 그 자체로 특수한 지위를 차지하는 것을 의미한다

## 5.2 핵심 설계 개념

- 복잡성 관리 - 소프트웨어의 주요 기술적 의무
    - 본질적 어려움과 비본질적 어려움
        - 소프트웨어 개발은 본질적/비본질적 어려움이 섞여 있음
        - 본질적 속성: 어떠한 사물이 그러한 사물이 되기 위해서 반드시 가져야 하는 속성 (예. 자동차가 되기 위해서 엔진, 바퀴, 문이 있어야 함)
        - 비본질적 속성: 특정 사물을 일컬을 때 그것이 무엇이라고 결정하는데 영향을 주지 않는 우연의 산물 (예. 자동차 문이 2개일 수도 있고, 4개일 수도 있음)
        - 본질적 어려움: 복잡하고 무질서한 현실 세계와 상호작용하고, 종속 관계와 예외 상황들을 정확하게 규명하며, 대충이 아닌 정확히 맞는 솔루션을 설계해야 함 (본질적인 어려움의 근원은 소프트웨어 개발의 본질적이고 비본질적인 복잡성 때문임)
        - 비본질적 어려움: 중요한 비본질적 어려움은 오래전에 해결되었음 (어셈블리어 → 3세대 언어로 진화, 통함프로그래밍개발환경 등)
    - 복잡성 관리의 중요성
        - 프로젝트가 기술적인 이유로 실패한 경우에는 그 원인을 복잡성 관리 부족에서 찾을 수 있음 → **소프트웨어의 주요 기술적 의무는 복잡성을 관리하는 것**
        - 한 번에 한 부분을 제대로 집중할 수 있게 프로그램을 구성해야 함 (한 번에 생각해야 하는 프로그램의 크기를 최소화 함)
        - 복잡한 문제를 간단한 문제로 나눔
        - 객체를 정의할 때 한 번에 하나의 기능에만 집중할 수 있도록 작업을 나눔
    - 복잡성을 해결하는 방법
        - 두뇌가 한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화 함
        - 비본질적인 복잡성이 불필요하게 증가하지 않도록 함
- 바람직한 설계의 특징
    - 복잡성 최소화 (재치있는 설계는 피하고, 간단하고 이해하기 쉬운 설계를 만듦, 특정한 부분을 살펴보고 있을 때 다른 부분에 대해서도 함께 살펴봐야 한다면 잘못된 설계라고 할 수 있음)
    - 유지보수의 편리함 (유지보수 개발자가 작성한 코드에 대해서 물어볼만한 질문을 떠올려 봄)
    - 느슨한 결합 (프로그램의 각 부분 사이의 연결을 최소화, 추상화/캡슐화/정보은닉과 같은 방법 사용)
        - 추상화: 사물이 가지는 특성을 잘 정리하여 필드와 메서드로 표현하는 과정 (공통의 속성/기능을 묶어 이름 붙이기, 패턴 찾아내기) → 예) 사자/물고기/토끼 를 '동물'로 추상화할 것인가? '생물'로 추상화할 것인가?
        - 캡슐화: 구현되는 부분을 외부에 드러나지 않도록 감싸 이용 방법만을 알려 주는 것, 데이터 구조(데이터 자체)와 데이터를 다루는 방법(메서드)을 결합시켜 묶는 것
        - 정보 은닉: 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 은닉 (객체, 상속, 캡슐화 등은 정보 은닉의 수단에 불과, 좋은 정보 은닉은 잘 된 추상화를 통해 얻어짐)
            - 객체의 구체적인 타입 은닉 (= 상위 타입 캐스팅)
            - 객체의 필드 및 메소드 은닉 (= 캡슐화)
            - 구현 은닉 (= 인터페이스 및 추상 클래스 기반의 구현)
    - 확장성 (내부 구조를 해치지 않고 시스템의 기능을 개선할 수 있음)
    - 재사용성 (현재 시스템의 일부를 다른 시스템에서 사용할 수 있도록 설계함)
    - 높은 팬인(fan-in) (특정 클래스를 사용하는 클래스의 수가 많음 → 유틸리티 클래스를 잘 활용하도록 설계함)
    - 낮은 팬아웃(fan-out) (특정 클래스가 다른 클래스를 적게 사용함)
    - 이식성 (시스템을 다른 환경으로 쉽게 이동시킬 수 있음)
    - 간결성 (불필요한 부분이 없게 시스템을 설계, 더이상 추가할 내용이 없을 때가 아니라 더 이상 뺄 내용이 없을 때)
    - 계층화 (특정 계층을 재구성할 때, 인터페이스 계층을 제외한 어떠한 코드도 변경할 필요가 없음)
    - 표준기법들 (표준화되고 일반적인 접근 방법을 사용)
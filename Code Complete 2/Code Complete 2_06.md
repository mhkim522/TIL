- 클래스 = 연관성이 높고 잘 정의된 기능을 공유하는 데이터와 루틴의 모음

## 6.1 클래스의 초대: 추상 데이터형(ADT, Abstract Data Type)

- 추상 데이터형
    - 데이터
    - 데이터를 처리하는 연산
        - 데이터가 무엇인지 설명해주는 역할
        - 데이터를 변경할 수 있게 해주는 역할
    - 클래스 = 추상 데이터형 + 상속 + 다형성
- 추상 데이터형을 사용할 때 좋은점
    - 구현 세부 사항을 감출 수 있다. (변경이 전체에 영향을 미치지 않는다와 연결됨)
    - 변경이 전체에 영향을 미치지 않는다.
    - 인터페이스가 더 많은 정보를 제공하도록 만들 수 있다. (전체 인터페이스를 일괄적으로 관리할 수 있음)
    - 성능을 향상시키기 쉽다. (성능 향상을 위해 프로그램 전체를 건드릴 필요 X)
    - 프로그램이 명백하게 정확해진다. (잘못된 연산, 잘못된 속성값 사용 등을 줄일 수 있음, 프로그램의 가독성이 높아진다와 연결됨)
    - 프로그램의 가독성이 높아진다.
    - 전체 프로그램에 데이터를 넘길 필요가 없다. (일부 루틴에서만 데이터(추상 데이터형은 데이터를 보관할 수 있는 구조임)에 접근할 수 있도록 할 수 있음)
    - 저수준 구현 구조체 대신 현실세계의 개체를 다룰 수 있다. (데이터 처리를 루틴의 집합으로 제한하여 더 나은 추상화 수준을 제공하고, 데이터 처리에 있어 보호막을 생성함)
- 추상 데이터형 사용 원칙
    - 전형적인 저수준 데이터형을 추상 데이터형으로 만들어 사용한다.
        - 스택/리스트/큐 뿐 아니라 전형적인 데이터형을 추상 데이터형으로 표현할 수 있음
        - 가능한 높은 추상화 수준에서 이해하고자 함 (지금 사용중인 스택/리스트/큐가 무엇을 표현하는 것인지에 초점을 맞춤)
    - 파일과 같은 일반적인 객체를 추상 데이터형으로 취급한다.
        - 예) 고급 언어는 데이터 버퍼를 조작하는 등의 복잡한 세부사항에 신경쓰지 않도록 해줌 → 디스크 공간을 '파일'로 처리할 수 있도록 해줌 (운영체제를 호출함으로써)
    - 간단한 객체도 추상 데이터형으로 취급한다.
    - 추상 데이터형이 저장된 매체와 독립적으로 추상 데이터형을 참조한다.
        - 예) 보험료 테이블
        - ReadFile.Read()와 같은 접근 루틴 → 저장방식에 연관됨 (보험료 테이블이 파일로 저장되어 있는것이 아니라면?)
        - rateTable.Read() → 저장방식과 연관되지 않음

## 6.2 좋은 클래스 인터페이스

- **고급 클래스**를 만들기 위한 가장 중요한 단계는 **좋은 인터페이스**를 만드는 것

### 좋은 추상화

- 클래스 인터페이스는 서로 밀접한 루틴을 제공해야 함 → 클래스 추상화에 대한 평가는 공개 루틴의 집합(=인터페이스)을 기초로 함

```cpp
// 잘못된 추상화의 예
class Program {
	public:
		...
		void InitializeCommandStack();
		void PushCommand(Command command); // 클래스가 stack을 처리하는 것이 공개됨
		Command PopCommand();
		void ShutdownCommandStack();
		// 클래스가 stack 명령을 처리하는 것과 보고서와 관련된 루틴을 처리하는 것은 연관성이 떨어짐
		void InitializeReporFormatting(); 
		void FormatReport(Report report);
		void PrintReport(Report report);
		...
	private:
		...
};

// 더 나은 추상화 (일부 루틴은 다른 클래스로 옮기고, 일부 루틴은 비공개 루틴으로 변환)
class Program {
	public:
		...
		void InitializeUserInterface();
		void ShutdownUserInterface();
		void InitializeReport();
		void ShutdownReport();
	private:
		...
};
```

- 좋은 추상 인터페이스를 작성하는 것이 클래스 인터페이스 생성에 도움을 줌
    - 클래스 인터페이스가 일관된 추상화 수준을 갖도록 함

    ```cpp
    // 추상화 수준이 뒤섞인 클래스 인터페이스
    // 내부적으로 컨테이너 클래스/라이브러리 클래스가 사용되었다는 사실을 감추지 않아 발생
    // 상속이 is a 관계를 위해서만 사용되었는지 생각해야 함
    // EmployeeCensus is a ListContainer? -> No
    class EmployeeCensus: public ListContainer {
    	public:
    		...
    		// 이 루틴들의 추상화는 '직원'을 다룸
    		void AddEmployee(Employee employee);
    		void RemoveEmployee(Employee employee);
    		// 이 루틴들의 추상화는 '리스트'를 다룸
    		Employee NexItemInList();
    		Employee FirstItem();
    		Employee LastItem();
    		...
    	private:
    		...
    };

    // 더 나은 추상화
    class EmployeeCensus {
    	public:
    		...
    		void AddEmployee(Employee employee); // 모든 루틴이 '직원'을 다룸
    		void RemoveEmployee(Employee employee);
    		Employee NextEmployee();
    		Employee FirstEmployee();
    		Employee LastEmployee();
    		...
    	private:
    		ListContainer m_EmployeeList; // 클래스가 ListContainer 라이브러리를 사용한다는 것이 노출되지 않음
    		...
    };
    ```

    - 클래스가 구현하고 있는 추상화가 무엇인지 이해해야 함 (예. 그리드 컨트롤 vs 스프레드시트 컨트롤)
    - 서로 반대되는 기능을 갖는 서비스 pair를 제공함 (각 공개 루틴에 반대되는 기능이 필요한지 확인)
    - 관련이 없는 정보를 다른 클래스로 옮김 (예. 루틴의 반이 일부 데이터를 다루고, 나머지 루틴이 나머지 데이터를 처리하는 경우 실제로는 두개의 서로 다른 클래스나 마찬가지임)
    - 가능하면 인터페이스를 의미론적이기보다는 프로그래밍적으로 만듦
        - 프로그래밍 적인 부분은 컴파일러로 강제화할 수 있음
        - 예) data1이 Routine1에 전달되기 전에 초기화 되어 있어야만 함 → 의미론적 인터페이스를 Assert나 Exception  등을 이용해 프로그래밍적인 인터페이스 요소로 강제화
    - 코드 변경시 인터페이스의 추상화가 망가지지 않도록 주의함
    - 인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 않음
    - 추상화와 응집도를 함께 고려함

### 좋은 캡슐화

- 추상화와 캡슐화
    - 추상화: 구현 세부 사항을 무시할 수 있는 모델을 제공함으로써 복잡성 관리에 도움을 줌
    - 캡슐화: 세부사항을 알고싶어할 때 조차 이를 원천적으로 봉쇄
- 좋은 캡슐화 방법
    - 클래스와 멤버의 접근성을 최소화함 (일반적으로 접근성을 숨기는 것이 숨기지 않는 것 보다 나음)
    - 멤버 데이터를 public으로 노출하지 않음 (클라이언트 코드가 멤버 변수를 직접 조작할 수 있고, 해당 클래스는 이 값들이 변경되었는지를 알 수 없음)
    - 내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 않음
        - 클래스 헤더 파일의 private 선언부 → 캡술화에 위반되지 않는 것처럼 보이지만, 다른 개발자들이 접근은 못하지만 구현 세부사항을 볼 수 있음
        - 클래스 구현부와 클래스 인터페이스를 분리

        ```cpp
        class Employee {
        	public:
        		...
        		Employee(
        			FullName name,
        			Jobclassfication jobClass
        			...
        		);
        		...
        		FullName GetName() const;
        		...
        	private:
        		String m_Name;
        		int m_jobClass; // 구현 세부 사항이 노출됨
        }

        class Employee {
        	public:
        		...
        		Employee(
        			FullName name,
        			Jobclassfication jobClass
        			...
        		);
        		...
        		FullName GetName() const;
        		...
        	private:
        			EmployeeImplementation *m_implementation // 구현 세부 사항이 포인터 내부에 감추어짐
        }
        ```

    - 클래스의 사용자를 가정하지 않음
        - 인터페이스 문서에 적혀있는 것 이외에 어떻게 사용될 것인지/사용되지 않을 것인지 등에 대해 어떠한 가정도 해서는 안됨
    - Friend 클래스는 피함 (서로 다른 클래스가 비공개 함수에 접근할 수 있도록 friend 키워드를 사용하는 것. 한 번에 생각해야 하는 코드의 양을 늘려 복잡성을 증가 시킴)
    - 어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 않음
    - 코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성 (현재 작업중인 특수한 상황에서 편의를 위해 루틴을 인터페이스에 추가하고 싶을 때가 있지만 그렇게 하면 안됨)
    - 캡슐화의 의미론적인 위반을 각별히 주의 (클라이언트 코드가 클래스의 public 인터페이스에 의존하지 않고 private 구현에 의존하지 않도록 주의)
        - 클래스를 어떻게 사용해야 하는지 알기 위해 클래스가 어떻게 구현되었는지를 확인하고 있다면, 인터페이스를 기반으로 프로그래밍하고 있기 보다는 구현부를 호출하기 위한 용도로만 인터페이스를 사용하고 있는 것임
        - **코드를 작성한 사람만 이해하고 있어서 클래스를 사용하는 사람이 이해하기 어려워서는 안됨**
        - **질문한 사람과 대화로 해결하면 안됨 (인터페이스를 통해서 해결해야 함)**
    - 지나치게 밀접한 결합을 주의
        - 클래스와 멤버의 접근성을 최소화
        - 파생 클래스와 기본 클래스가 느슨하게 연결되도록 protected가 아닌 private으로 선언
        - 클래스의 공개 인터페이스에서 멤버 데이터를 노출하지 않음
        - 데미테르의 법칙을 준수

## 6.3 설계와 구현 문제

### 포함 (has a 관계)

- has a 관계일 때, 클래스의 멤버 데이터로 만들어 포함을 구현할 수 있음
- 또는 포함되는 객체로부터 비공개적으로 상속을 받음
    - 포함하는 클래스가 포함되는 클래스의 protected 멤버 함수/데이터에 접근 가능
    - 지나치게 밀접한 관계를 만들고 캡슐화를 위반할 수 있음
- 클래스가 7개 이상의 데이터 멤버를 포함한다면 클래스를 더 작은 클래스로 나눌 수 있는지 고민
    - 데이터가 정수/문자열과 같이 단순한 데이터형이라면 9개(7±2 법칙)까지 허용
    - 복잡한 데이터라면 5개(7±2 법칙) 정도로 허용

### 상속 (is a 관계)

- 두 개 이상의 파생 클래스에서 공통으로 사용되는 요소를 가지는 기본 클래스를 정의하여 더 간단한 코드를 작성하는 것이 목적임
- 상속을 사용하기로 했을 때 결정해야 할 사항
    - 공개 상속을 통해 is a를 구현
        - 파생 클래스는 기본 클래스의 '특수화된 버전'임
        - 기본 클래스는 파생 클래스의 작동을 예측하고 제약할 수 있음
        - 파생 클래스가 기본 클래스에 정의된 인터페이스를 완벽하게 따르지 않는다면, 상속이 올바른 구현 기법이 아닐 수 있음
    - 상속을 고려해서 설계하고 문서화 (그게 아니면 상속을 금지)
        - 상속은 프로그램을 복잡하게 만들기 때문에 위험한 기법임
    - 리스코프 치환 원칙(LSP: Liskov Substitution Principle)을 따름
        - 기본 클래스에 정의된 모든 루틴은 파생 클래스에서 사용될 때에도 의미가 같아야 함
        - 파생 클래스를 구현할 때 의미적인 차이점에 대해서 끊임없이 생각해야 한다면 상속이 복잡성을 줄이기보다 늘리는 격이 됨
    - 상속 받고 싶을 때만 상속 받게 함
        - 오버라이드 가능한 추상 루틴 - 인터페이스 상속O/구현 상속 X/오버라이드O
        - 오버라이드 가능한 루틴 - 인터페이스 상속O/구현 상속O/오버라이드O
        - 오버라이드 불가능한 루틴 - 인터페이스 상속O/구현 상속O/오버라이드X
        - **인터페이스는 필요없고, 구현만 사용하고 싶다면 상속 대신 포함을 사용**
    - 오버라이드가 불가능한 멤버 함수를 오버라이드 하지 않음 (= 오버라이드가 불가능한 기본 클래스 루틴의 이름을 파생 클래스에서 재사용하지 않음)
    - 공통으로 사용되는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 가장 높은 곳으로 옮김 (추상화를 깨지 않을 때까지)
    - 인스턴스가 하나뿐이 클래스를 의심
        - 객체를 클래스로 잘못 알고 설계 했을 수 있음 → 객체? 클래스?
    - 파생 클래스가 하나뿐인 기본 클래스를 의심
        - 개발자가 너무 앞서 나가서 설계했을 수 있음
        - 가능한 현재의 작업을 분명/직관/단순하게 만드는데 집중
    - 루틴을 오버라이드 했는데 파생된 루틴 내부에서는 아무것도 하지 않는 클래스들을 의심
        - 기본 클래스의 설계에 오류가 있을 수 있음

        ```csharp
        // 좋지 않은 예
        // 근본적인 문제는 모든 고양이가 긁는다는 가정에서 시작되었음
        class Cat {
        	...
        	void virtual Scratch() {
        		// Scratch에 대한 정의
        	}
        };

        class ScratchlessCat : Cat {
        	void override Scratch() {
        		// Nothing to do
        		// 인터페이스의 의미를 변경함으로써 Cat 클래스에 있는 추상화를 위반
        		// 부모 클래스의 인터페이스와 자식 클래스의 인터페이스 행위 사이에 연관성이 없음
        	}
        }

        // 좋은 예
        class Claws {
        	void Scratch() {
        		// Scratch에 대한 정의
        	}
        }

        class Cat {
        	...
        	Claws claws;
        	...
        };
        ```

    - 깊은 상속 구조를 피함
        - 상속 계층은 2~3단계 내로 제한
        - 기본 클래스에서 파생된 서브 클래스의 총 갯수를 7±2개로 제한
        - 깊은 상속은 복잡성을 증가시켜 애초에 상속을 사용하는 목적을 무색하게 만듦
    - 광범위한 타입 검사보다 다형성을 택함
        - switch-case 문의 경우 다형성을 택할 수 없는지 한 번 더 고민
    - 모든 데이터를 보호가 아닌 비공개로 만들어라
        - 파생 클래스에서 기본 클래스의 특성에 접근해야 한다면 protected로 선언된 함수를 대신 제공